*	
В каких учебных заведениях, курсах вы обучались программированию или какие материалы использовали?
- "Высшая школа программирования Сергея Бобровского", Курс "Алгоритмы и структуры данных"
- "Высшая школа программирования Сергея Бобровского", Курс "Программирование Python "С нуля"

* 
Материалы:
Э. Мэтиз "Изучаем Python"
М. Лутц "Изучаем Python"
С. Макконелл "Совершенный код"
Р. Мартин "Чистый код"
Н. Прохоренок и В. Дронов "HTML, CSS, JS, PHP и MySQL" (в части касающейся HTML и CSS)

*
Опишите словами алгоритм решения задачи
Ввод: натуральное число n
Вывод: количество простых чисел строго меньше n
Решение должно быть вычислительно-эффективным

Решение:
Граничный случай - для n < 3 количество простых множителей равно n
Для остальных:
1. Формируем список List.
2. Итератор пробегает от 2 до n-1 и каждое число проверяет на простоту. Выявленное простое число добавляется в список List.
3. В конце возвращаем размер List + 1 (так как в списке нет единицы).

Для проверки очередного числа на простоту - отдельная функция.
На вход - проверяемое число, список List.
На выход - boolean-значение.
Функция будет "ленивая", простые множители она будет брать  из списка List, а не перебирать все натуральные числа.
- пробегаем по списку, берем из него простые множители
- проверяем остаток от деления проверяемого числа на очередной множитель, если делится - False, выход
- если список успешно пройден - возвращаем True

*
*	
Дан массив N и число k <= len(N)/2
Опишите алгоритм разбиения массива длины N на k подмассивов так, чтобы размер самого длинного и самого короткого подмассива отличалась не больше чем на 1
Чему будут равны длины подмассивов?
Может ли k быть больше длины N?

Решение:
Не сразу сообразил...
Задача сводится к получению частного (результата деления) в виде смешанного числа с правильной дробью.
<<Например, массив длиной 20 делим на 6 подмассивов.
Результат деления - это 3 целых и 2/6. (или 3 1/3)
Очевидный ответ - часть подмассивов длиной 3, часть - длиной 4. >>
Тогда целая часть этого результата - размер "малого" подмассива, а числитель дробной части - это доля "больших" в общем количестве подмассивов. 
То есть, для этого примера, говоря словами, получим 6 подмассивов, два из которых размером 4, а  остальные - размером 3.
Тогда размеры подмассивов равны:
"меньшего" -                     N // k
"большего" -                      N // k + 1
Количество "больших"     N % k
Количество  "малых"     k - (N % k)

*
Дан массив неповторяющихся чисел, который был отсортирован, а затем циклически сдвинут на неизвестное число позиций.
Опишите без кода и псевдокода алгоритм поиска максимума в таком массиве
Оцените сложность предложенного алгоритма
Изменится ли сложность если массив содержит повторяющиеся числа?

Решение:
Предположим, массив сортирован по возрастанию.
Пробегаем по массиву, ищем место, в котором "возрастание" (i+1-й элемент больше  i -того) превращается в "убывание" - это точка "склейки" первого и последнего элементов. 
Таким образом найдем сразу стоящие рядом "максимум" и "минимум". Если во всем массиве не нашлось такой точки(неравенство везде верное), то это значит, что сдвиг произошел
на величину, кратную размеру массива (или 0). Тогда первый (i=0) элемент - минимум, последний (i = -1) - максимум.
Сложность (временная) - O(N)
Наличие повторяющихся чисел алгоритм не усложнит, только проверку надо будет проводить на нестрогое неравенство (i+1-й элемент больше или равен i -того). 

*
Напишите регулярное выражение, которое позволяет выделить все строки отвечающие условиям:

Состоят только из букв
Одна и только одна из букв является заглавной

Пример строк которые могут быть выделены варажением:
"Мама",
"авТо",
"гриБ",
'Яблоко', 'яБлоко', 'ябЛоко', 'яблОко', 'яблоКо', 'яблокО'

Пример строк которые не должны быть выделены выражением:
"агент007" - содержит цифры
"стриж" - только строчные буквы
"ГТО", - более одной заглавной буквы
"Три богатыря" - содержит пробел, допустимы только буквы

Это задание проверяется автоматическим тестированием в Python и оценивается высоко в случае прохождения всех тестов

Решение:
r'[а-яё]{0,}[А-ЯЁ]{1}[а-яё]{0,}'

*
Дан указатель на корень двоичного дерева
Опишите словами алгоритм, который вернёт True если дерево является двоичным деревом поиска и False если не является

Вершина дерева содержит целочисленное значение (value) и два указателя на поддеревья (left и right).

В виде структуры на языке C это можно записать так:

struct node {
  int value;
  node* left;
  node* right;
}

Решение:
Надо "обойти" дерево, вертикально (рекурсивно), порядок - неважен (pre-ordered, in-ordered или post-ordered).
В каждой ноде current  проверять условия: 
- current.left is None or current.left.value < current.value 
  (в левом потомке переменная меньше чем в родителе или левый потомок не существует)
- current.right is None or current.right.value > current.value 
  (в правом потомке переменная больше чем в родителе или правый потомок не существует)
При невыполнении хотя бы одного условия - обход прерывается, возвращаем False
После обхода - возвратить True (если функция не прервалась, значит все условия соблюдены)


*
В реляционной базе данных существуют таблицы:

Cities - список городов

id - первичный ключ
name - название
population - численность населения
founded - год основания
country_id - id страны

Countries - список стран

id - первичный ключ
name - название
population - численность населения
gdp - валовый продукт в долларах

Companies - компании

id - первичный ключ
name - название
city_id - город в котором находится штаб-квартира
revenue - годовая выручка в долларах
labors - численность сотрудников

Постройте таблицу, где для каждой страны посчитано число компаний, удволетворяющих условиям:

1) штаб квартира компании находится в этой стране
2) число сотрудников компании не менее 1000 человек

Решение:

